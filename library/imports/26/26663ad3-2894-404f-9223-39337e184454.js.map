{"version":3,"sources":["assets/Script/common/TaskQueue.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["/*\n*   任务队列管理器\n*   1. 传入任务，进入队列顺序执行\n*   2. 支持优先级（从小到大排序，priority越小优先级越高）\n*   3. 支持队列Tag，允许多个互不影响的队列执行\n*   4. 支持清理任务队列\n*   5. 一个任务只能完成一次，避免代码的原因多次调用完成，导致后续任务提前执行\n*\n*   6. 调试模式下记录了每个Task添加时的堆栈，方便调试（可以快速查看哪个任务没有结束）\n*   \n*   2018-5-7 by 宝爷\n*/\n\n\n// 任务结束回调\nexport type TaskFinishCallback = () => void;\n// 任务执行回调\nexport type TaskCallback = (TaskFinishCallback) => void;\n\nclass TaskInfo {\n    public task: TaskCallback;\n    public priority: number;\n    public constructor(task: TaskCallback, priority: number) {\n        this.task = task;\n        this.priority = priority;\n    }\n}\n\nexport class TaskQueue {\n    private _curTask: TaskInfo = null;\n    private _taskQueue: TaskInfo[] = Array<TaskInfo>();\n\n    // 添加一个任务，如果当前没有任务在执行，该任务会立即执行，否则进入队列等待\n    public pushTask(task: TaskCallback, priority: number = 0): void {\n        let taskInfo = new TaskInfo(task, priority);\n        if (this._taskQueue.length > 0) {\n            for (var i: number = this._taskQueue.length - 1; i >= 0; --i) {\n                if (this._taskQueue[i].priority <= priority) {\n                    this._taskQueue.splice(i + 1, 0, taskInfo);\n                    return;\n                }\n            }\n        }\n        // 插到头部\n        this._taskQueue.splice(0, 0, taskInfo);\n        if (this._curTask == null) {\n            this.executeNextTask();\n        }\n    }\n\n    public clearTask(): void {\n        this._curTask = null;\n        this._taskQueue.length = 0;\n    }\n\n    private executeNextTask(): void {\n        let taskInfo = this._taskQueue.shift() || null;\n        this._curTask = taskInfo;\n        if (taskInfo) {\n            taskInfo.task(() => {\n                if (taskInfo === this._curTask) {\n                    this.executeNextTask();\n                } else {\n                    console.warn(\"your task finish twice!\");\n                }\n            });\n        }\n    }\n}\n\nexport class TaskManager {\n    private static _instance: TaskManager = null;\n    private _taskQueues: { [key: number]: TaskQueue } = {}\n\n    public static getInstance(): TaskManager {\n        if (!this._instance) {\n            this._instance = new TaskManager();\n        }\n        return this._instance;\n    }\n\n    public static destory(): void {\n        this._instance = null;\n    }\n\n    private constructor() {\n\n    }\n\n    public pushTask(task: TaskCallback, priority: number = 0): void {\n        return this.getTaskQueue().pushTask(task, priority);\n    }\n\n    public pushTaskByTag(task: TaskCallback, tag: number, priority: number = 0): void {\n        return this.getTaskQueue(tag).pushTask(task, priority);\n    }\n\n    public clearTaskQueue(tag: number = 0): void {\n        let taskQueue = this._taskQueues[tag];\n        if (taskQueue) {\n            taskQueue.clearTask();\n        }\n    }\n\n    public clearAllTaskQueue(): void {\n        for (let queue in this._taskQueues) {\n            this._taskQueues[queue].clearTask();\n        }\n        this._taskQueues = {}\n    }\n\n    private getTaskQueue(tag: number = 0): TaskQueue {\n        let taskQueue = this._taskQueues[tag];\n        if (taskQueue == null) {\n            taskQueue = new TaskQueue();\n            this._taskQueues[tag] = taskQueue;\n        }\n        return taskQueue;\n    }\n}\n\n/* 测试用例：\n* 1. 测试多个任务的执行顺序 + 优先级\n* 2. 测试在执行任务的过程中动态添加新任务\n\nexport function testQueue() {\n    let creatTask = (idx, pri): TaskCallback => {\n        return (finish) => {\n            console.log(`execute task ${idx} priority ${pri}`);\n            finish();\n        };\n    };\n    let tag = 0;\n    let begin = (finish) => {\n        for (var i = 0; i < 100; ++i) {\n            let priority = 0;\n            if (i % 10 == 0) {\n                priority = -1;\n            } else if (i == 88) {\n                priority = 1;\n            } else if (i == 22) {\n                let task = creatTask(1.1, priority);\n                TaskManager.getInstance().pushTaskByTag(task, tag, priority);\n                task = creatTask(1.2, priority);\n                TaskManager.getInstance().pushTaskByTag(task, tag, priority);\n                task = creatTask(1.3, priority);\n                TaskManager.getInstance().pushTaskByTag(task, tag, priority);\n            } else if (i == 51 && tag == 2) {\n                // 清理之后，添加的任务会立即执行...\n                TaskManager.getInstance().clearTaskQueue(tag);\n            }\n            let task = creatTask(i, priority);\n            Object.defineProperty(task, \"idx\", { value: i });\n            TaskManager.getInstance().pushTaskByTag(task, tag, priority);\n        }\n        console.log(\"add task finish, start test\");\n        finish();\n        // 测试重复调用结束\n        finish();\n        // tag为2时的finish两次都会报警告，因为begin已经被清理了\n    }\n    TaskManager.getInstance().pushTaskByTag(begin, tag);\n    tag = 2;\n    TaskManager.getInstance().pushTaskByTag(begin, tag);\n\n}*/\n"]}